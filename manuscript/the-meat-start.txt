{mainmatter}

{#the-meat-start}
# Visualizing data with React and d3.js #

Welcome to the main part of React + D3 2018. We're going to talk a little theory, learn some principles, then get our hands dirty with some examples. Through this book you're going to build:

- [A few small components in Codesandbox](#basic-approach)
- [A choropleth map](#choropleth-map)
- [An interactive histogram](#histogram-of-salaries)
- [A bouncing ball](#bouncing-ball)
- [A rainbow snake](#rainbow-snake)
- [An animated alphabet](#animated-alphabet)
- [A simple particle generator with Redux](#animating-react-redux)
- [A particle generator pushed to 20,000 elements with canvas](#canvas-react-redux)
- [Billiards simulation with MobX and canvas](#billiards-simulation)
- [A dancing fractal tree](#fractal-tree)

Looks random, right? Bear with me. Examples build on each other. 

The first few examples teach you about static data visualizations and the basics of merging React and D3 using two different approaches.

The choropleth and histogram visualizations teach you about interactivity and components working together.

You learn about game loop and transition animations through two types of bouncing balls. Followed by more complex enter/exit transitions with an animated alphabet.

We look at how far we can push React's performance with a simple particle generator and a dancing fractal tree. A billiards game helps us learn about complex canvas manipulation.

Throughout these examples, we're going to use **React 16**, compatible with **React 17**, **D3v5**, and modern **ES6+** JavaScript syntax. The particle generator also uses **Redux** for the game loop and the billiards simulation uses MobX. We use **Konva** for complex canvas stuff.

That way you can build experience in large portions of the React ecosystem so you can choose what you like best.

Don't worry, if you're not comfortable with modern JavaScript syntax just yet. By the end of this book, you're gonna love it!

Until then, here's an interactive cheatsheet: [es6cheatsheet.com](https://es6cheatsheet.com/). It uses runnable code samples to compare the ES5 way with the ES6 way so you can brush up quickly.

To give you a taste of React alternatives, we'll check out **Preact**, **Inferno**, and **Vue** in the fractal tree example. They're component-based UI frameworks similar to React. Preact is tiny, Inferno is fast, and Vue is about as popular as React.

----

Let's talk about how React and D3 fit together. If there's just one chapter you should read, this is the one. It explains how things work and fit together. Takes you from beginning to being able to figure out the rest on your own.

Although you should still play with the bigger examples. They're fun.

This section has five chapters:

- [A quick intro to D3](#d3-quick-intro)
- [How React makes D3 easier](#basic-approach)
- [When should you use an existing library? Which one?](#existing-libraries)
- [Quickly integrate any D3 code in your React project with Blackbox Components](#blackbox-components)
- [Build scalable dataviz components with full integration](#full-feature-integration)
- [State Handling Architecture](#state-handling-architecture)
- [Structuring your React App](#structuring-your-app)

{#d3-quick-intro}
# A quick intro to D3

D3 is the best library out there for custom data visualization. It comes with a rich ecosystem of functions for almost anything you can think of. From simple medians, to automatic axis generators, and force diagrams.

Most data visualization you see on the web is built with D3. The New York Times uses it, Guardian uses it, r/dataisbeautiful is full of it.

Learning D3 from scratch is where life gets tricky.

There are several gotchas that trip you up and make examples look like magic. You've probably noticed this, if you ever looked at an example project built with D3. They're full of spaghetti code, global variables, and often aren't made to be maintainable.

Most examples are just one-off toys after all. It's art.

A lot of dataviz that *isn't* art, is charts and graphs. You'll often find that using D3 to build those, is too complicated. D3 gives you more power than you need.

If you want charts, I suggest using a charting library. 

Where many charting libraries fall short is customization. The API is limited, you can't do everything you want, and it gets easier to just build it yourself.

A lot of what you end up doing in real life is finding a D3 example that looks like what you want to build and adapting it. That's why you should learn at least some D3.

But D3 is hard to read. Take this barchart code, for example ðŸ‘‡

{caption: "Barchart in pure D3", line-numbers: false}
```javascript
d3.tsv("data.tsv", function(d) {
  d.frequency = +d.frequency;
  return d;
}, function(error, data) {
  if (error) throw error;

  x.domain(data.map(function(d) { return d.letter; }));
  y.domain([0, d3.max(data, function(d) { return d.frequency; })]);

  g.append("g")
      .attr("class", "axis axis--x")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(x));

  g.append("g")
      .attr("class", "axis axis--y")
      .call(d3.axisLeft(y).ticks(10, "%"))
    .append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("dy", "0.71em")
      .attr("text-anchor", "end")
      .text("Frequency");

  g.selectAll(".bar")
    .data(data)
    .enter().append("rect")
      .attr("class", "bar")
      .attr("x", function(d) { return x(d.letter); })
      .attr("y", function(d) { return y(d.frequency); })
      .attr("width", x.bandwidth())
      .attr("height", function(d) { return height - y(d.frequency); });
});
```

Can you tell what's going on? I'd need to read it pretty carefully.

Which brings us to ðŸ‘‡

## 3 key insights that help you learn D3.js from scratch

Somebody once asked me how to learn D3.js from scratch. I quipped that it took me writing a book to really learn it. It's one hell of a library.

Most people don't go that far. They don't have to. 

You start with a problem, find similar examples, do some copy pasta, tweak until it works and end up with a working visualization you don't understand. You'd be surprised how few engineers actually understand how their D3 data visualization works.

Fear not! There are just 3 key concepts you have to grok. Then you can understand every D3 example out there. ðŸ˜±

### 1) Data manipulation vs. DOM manipulation

All D3 examples are split into two parts: 

1. Data manipulation
2. DOM manipulation 

First you prep your values, then you render.

You have to go through many examples to notice what's going on. Inference learning is hard. Most beginners miss this pattern and it makes D3 look more confusing than it is.

Let's take an example from [D3's docs](https://github.com/d3/d3/wiki/Gallery), a bar chart with a hover effect.

![An example D3 barchart](images/2018/barchart-example.png)

You can [try it online](https://cdn.rawgit.com/mbostock/3885304/raw/a91f37f5f4b43269df3dbabcda0090310c05285d/index.html). When you hover on a bar, it changes color. Pretty neat.

Mike Bostock, the creator of D3, built this chart in 43 lines of code. Here they are ðŸ‘‡

{caption: "Example D3 barchart", line-numbers: false}
```javascript
var svg = d3.select("svg"),
    margin = {top: 20, right: 20, bottom: 30, left: 40},
    width = +svg.attr("width") - margin.left - margin.right,
    height = +svg.attr("height") - margin.top - margin.bottom;

var x = d3.scaleBand().rangeRound([0, width]).padding(0.1),
    y = d3.scaleLinear().rangeRound([height, 0]);

var g = svg.append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

d3.tsv("data.tsv", function(d) {
  d.frequency = +d.frequency;
  return d;
}, function(error, data) {
  if (error) throw error;

  x.domain(data.map(function(d) { return d.letter; }));
  y.domain([0, d3.max(data, function(d) { return d.frequency; })]);

  g.append("g")
      .attr("class", "axis axis--x")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(x));

  g.append("g")
      .attr("class", "axis axis--y")
      .call(d3.axisLeft(y).ticks(10, "%"))
    .append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("dy", "0.71em")
      .attr("text-anchor", "end")
      .text("Frequency");

  g.selectAll(".bar")
    .data(data)
    .enter().append("rect")
      .attr("class", "bar")
      .attr("x", function(d) { return x(d.letter); })
      .attr("y", function(d) { return y(d.frequency); })
      .attr("width", x.bandwidth())
      .attr("height", function(d) { return height - y(d.frequency); });
});
```

There are two parts to this code: Data manipulation and DOM manipulation.

{caption: "Data manipulation code", line-numbers: false}
```javascript
var // ..,
    margin = {top: 20, right: 20, bottom: 30, left: 40},
    width = +svg.attr("width") - margin.left - margin.right,
    height = +svg.attr("height") - margin.top - margin.bottom;

var x = d3.scaleBand().rangeRound([0, width]).padding(0.1),
    y = d3.scaleLinear().rangeRound([height, 0]);

// ...

d3.tsv("data.tsv", function(d) {
  d.frequency = +d.frequency;
  return d;
}, function(error, data) {
  if (error) throw error;

  x.domain(data.map(function(d) { return d.letter; }));
  y.domain([0, d3.max(data, function(d) { return d.frequency; })]);

// ...
});
```

Bostock here first prepares his data: 

- some sizing variables (`margin`, `width`, `height`)
- two scales to help with data-to-coordinates conversion (`x, y`)
- loads his dataset (`d3.tsv`) and updates his scales' domains

In the DOM manipulation part, he puts shapes and objects into an SVG. This is the part that shows up in your browser.

{caption: "DOM manipulation code", line-numbers: false}
```javascript
var svg = d3.select("svg"),
    // ..
    
// ..

var g = svg.append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

// ..
  g.append("g")
      .attr("class", "axis axis--x")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(x));

  g.append("g")
      .attr("class", "axis axis--y")
      .call(d3.axisLeft(y).ticks(10, "%"))
    .append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("dy", "0.71em")
      .attr("text-anchor", "end")
      .text("Frequency");

  g.selectAll(".bar")
    .data(data)
    .enter().append("rect")
      .attr("class", "bar")
      .attr("x", function(d) { return x(d.letter); })
      .attr("y", function(d) { return y(d.frequency); })
      .attr("width", x.bandwidth())
      .attr("height", function(d) { return height - y(d.frequency); });
});
```

DOM manipulation in D3 happens via D3 selections. They're a lot like jQuery `$(something)`. This is the part we're doing with React later on.

Here Bostock does a few things

- selects the `<svg>` node (`d3.select`)
- appends a grouping `<g>` node (`.append`) with an SVG positioning attribute (translate)
- adds a bottom axis by appending a `<g>`, moving it, then calling `d3.axisBottom` on it. D3 has built-in axis generators
- adds a left axis using the same approach but rotating the ticks
- appends a text label "Frequency" to the left axis
- uses `selectAll.data` to make a virtual selection of `.bar` nodes and attach some data, then for every new data value (.enter), appends a `<rect>` node and gives it attributes

That last part is where people get lost. It looks like magic. Even to me.

It's a declarative approach to rendering data. Works great, hard to understand. That's why we'll do it in React instead :)

You can think of `.enter` as a loop over your data. Everything chained after `.enter` is your loop's body. Sort of like doing `data.map(d => append(rect).setManyAttributes())`

That function executes for any *new* data "entering" your visualization. There's also `.exit` for anything that's dropping out, and `.update` for anything that's changing.

### 2) Scales

Scales are D3's most versatile concept. They help you translate between two different spaces. Like, mathematical spaces.

They're like the mathematical functions you learned about in school. A domain maps to a range using some sort of formula.

![A basic function](https://upload.wikimedia.org/wikipedia/commons/thumb/d/df/Function_color_example_3.svg/440px-Function_color_example_3.svg.png)

Colored shapes in the domain map to colors in the range. No formula for this one. That makes it an ordinal scale.

```javascript
let shapes = d3.scaleOrdinal()
	.domain(['red', 'orange', ...)
	.range(['red', 'orange', ...)
```

[Play with scales on CodeSandbox](codesandbox://intro-to-d3/scales)

Once you have this scale, you can use it to translate from shapes to colors. `shapes('red triangle')` returns `'red'` for example.

Many different types of scales exist. Linear, logarithmic, quantize, etc. Any basic transformation you can think of exists. The rest you can create by writing custom scales.

You're most often going to use scales to turn your data values into coordinates. But other use-cases exist.

### 3) D3 layouts

Sure `.enter.append` looks like magic, but D3 layouts are the real mind=blown of the D3 ecosystem. They take your input data and return a full-featured visualization thing.

For example, a force layout using forces between nodes to place them on the screen.

![Force layout](images/2018/force-layout.png)

Or a circle packing layout that neatly packs circles.

![Circle packing layout](images/2018/circle-packing-layout.png)

I don't know the maths that goes into most of these. And that's the point, you shouldn't have to!

Here's a key insight about the magic of layouts: They're the data part.

You take a `forceLayout` and feed it your data. It returns an object with a `tick` event callback.

```javascript
var simulation = d3.forceSimulation()
    .force("link", d3.forceLink().id(function(d) { return d.id; }))
    .force("charge", d3.forceManyBody())
    .force("center", d3.forceCenter(width / 2, height / 2));
```

This `simulation` now handles everything *about* rendering your nodes. Changes their positions on every `tick` callback, figures out how often to change stuff, etc.

But it is up to you to render them. A layout handles your dataviz in the abstract. You're in control of the rendering.

For a force layout, you have to update the DOM on every tick of the animation. For circle packing, you render it once.

Once you grok this, all the fancy visualizations out there start making sense. Also means you can use these fancy layouts in React ðŸ™Œ

## Recap

There's a lot more D3 can do, but those are the 3 key insights you need to understand any example you find in the wild.

1. Code is split into data and DOM manipulation
2. Scales are great and used a lot
3. You're always in control of rendering

Then you can start using D3's more advanced features like maps and axes and shape generators and geo computations and data loading and transitions and user interactions.

There's a lot. We're not going to cover it all but you can find those advanced features in the docs and the skills you learn here will help you get started.

{#basic-approach}
# How React makes D3 easier

Our visualizations are going to use SVG â€“ an XML-based image format that lets us describe images in terms of mathematical shapes. For example, the source code of an 800x600 SVG image with a rectangle looks like this:

{caption: "SVG rectangle", line-numbers: false}
```html
<svg width="800" height="600">
    <rect width="100" height="200" x="50" y="20" />
</svg>
```

These four lines create an SVG image with a black rectangle at coordinates `(50, 20)` that is 100x200 pixels large. Black fill with no borders is default for SVG shapes.

SVG is perfect for data visualization on the web because it works in all browsers, renders without blurring or artifacts on all screens, and supports animation and user interaction. You can see examples of interaction and animation later in this book.

But SVG can get slow when you have many thousands of elements on screen. We're going to solve that problem by rendering bitmap images with canvas. More on that later.

----

Another nice feature of SVG is that it's just a dialect of XML - nested elements describe structure, attributes describe the details. Same principles that HTML uses.

That makes React's rendering engine particularly suited for SVG. Our 100x200 rectangle from before looks like this as a React component:

{caption: "A simple rectangle in React", line-numbers: false, format: javascript}
```
const Rectangle = () => (
    <rect width="100" height="200" x="50" y="20" />
);
```

To use this rectangle component in a picture, you'd use a component like this:

{caption: "Rect component in a picture", line-numbers: false, format: javascript}
```
const Picture = () => (
    <svg width="800" height="600">
        <Rectangle />
    </svg>
);
```

Sure looks like tons of work for a static rectangle. But look closely! Even if you know nothing about React and JSX, you can look at that code and see that it's a `Picture` of a `Rectangle`.

Compare that to a pure D3 approach:

{caption: "A static rectangle in d3.js", line-numbers: false, format: javascript}
```
d3.select("svg")
  .attr("width", 800)
  .attr("height", 600)
  .append("rect")
  .attr("width", 100)
  .attr("height", 200)
  .attr("x", 50)
  .attr("y", 20);
```

It's elegant, it's declarative, and it looks like function call soup. It doesn't scream *"Rectangle in an SVG"* to as much as the React version does.

You have to take your time and read the code carefully: first, we `select` the `svg` element, then we add attributes for `width` and `height`. After that, we `append` a `rect` element and set its attributes for `width`, `height`, `x`, and `y`.

Those 8 lines of code create HTML that looks like this:

{caption: "HTML of a rectangle", line-numbers: false, format: javascript}
```
<svg width="800" height="600">
    <rect width="100" height="200" x="50" y="20" />
</svg>
```

Would've been easier to just write the HTML, right? Yes, for static images, you're better off using Photoshop or Sketch then exporting to SVG.

Dealing with the DOM is not D3's strong suit. There's a lot of typing, code that's hard to read, it's slow when you have thousands of elements, and it's often hard to keep track of which elements you're changing. D3's enter-update-exit cycle is great in theory, but most people struggle trying to wrap their head around it.

If you don't understand what I just said, don't worry. We'll cover the enter-update-exit cycle in the animations example. 

Don't worry about D3 either. **It's hard!** I've written two books about D3, and I still spend as much time reading the docs as writing the code. The library is huge and there's much to learn. I'll explain everything as we go along.

D3's strong suit is its ability to do everything except the DOM. There are statistical functions, great support for data manipulation, a bunch of built-in data visualizations, magic around transitions and animation ... **D3 can calculate anything for you. All you have to do is draw it out.**

That's why our general approach sounds like this in a nutshell:

* React owns the DOM
* D3 calculates properties

We leverage React for SVG structure and rendering optimizations; D3 for its mathematical and visualization functions.

Now let's look at three different ways of using React and D3 to build data visualization:
- using a library
- quick blackbox components
- full feature integration

{#existing-libraries}
# When should you use an existing library? Which one?

{#blackbox-components}
# Quickly integrate any D3 code in your React project with Blackbox Components

Blackbox components are the simplest way to integrate D3 and React. You can think of them as wrappers around D3 visualizations.

With the blackbox approach, you can take any D3 example from the internets or your brain, wrap it in a React component, and it Just Worksâ„¢. This is great when you're in a hurry, but comes with a big caveat: You're letting D3 control some of the DOM.

D3 controlling the DOM is *okay*, but it means React can't help you there. That's why it's called a Blackbox â€“Â React can't see inside.

No render engine, no tree diffing, no dev tools to inspect what's going. Just a blob of DOM elements.

Okay for small components or when you're prototyping, but I've had people come to my workshops and say *"We built our whole app with the blackbox approach. It takes a few seconds to re-render when you click something. Please help"*

ðŸ¤”

Here's how it works:
- React renders an anchor element
- D3 hijacks it and puts stuff in

You manually re-render on props and state changes. Throwing away and rebuilding the entire DOM subtree on each render. With complex visualizations this becomes a huge hit on performance.

Use this technique sparingly.

{#blackbox-axis}
## A quick blackbox example - a D3 axis

Let's build an axis component. Axes are the perfect use-case for blackbox components. D3 comes with an axis generator bundled inside, and they're difficult to build from scratch.

They don't *look* difficult, but there are many tiny details you have to get _just right_.

D3's axis generator takes a scale and some configuration to render an axis for us. The code looks like this:

{caption: "Vanilla D3 axis",line-numbers: false, format: javascript}
```
const scale = d3.scaleLinear()
		.domain([0, 10])
		.range([0, 200]);
const axis = d3.axisBottom(scale);

d3.select('svg')
  .append('g')
  .attr('transform', 'translate(10, 30)')
  .call(axis);
```

You can [try it out on CodeSandbox](https://codesandbox.io/s/v6ovkow8q3).

If this code doesn't make any sense, don't worry. There's a bunch of D3 to learn, and I'll help you out. If it's obvious, you're a pro! This book will be much quicker to read.

We start with a linear scale that has a domain `[0, 10]` and a range `[0, 200]`. Scales are like mathematical functions that map a domain to a range. In this case, calling `scale(0)` returns `0`, `scale(5)` returns `100`, `scale(10)` returns `200`. Just like a linear function from math class â€“Â y = kx + n.

We create an axis generator with `axisBottom`, which takes a `scale` and creates a `bottom` oriented axis â€“ numbers below the line. You can also change settings for the number of ticks, their sizing, spacing, and so on.

Equipped with an `axis` generator, we `select` the `svg` element, append a grouping element, use a `transform` attribute to move it `10`px to the right and `30`px down, and invoke the generator with `.call()`.

It creates a small axis:

![Simple axis](images/es6v2/simple-axis.png)

Play around with it on [Codesandbox](https://codepen.io/swizec/pen/YGoYBM). Change the scale type, play with axis orientation. Use `.ticks` on the axis to change how many show up. Have some fun :)

## A quick blackbox example - a React+D3 axis

Now let's say we want to use that same axis code but as a React component. The simplest way is to use a blackbox component approach like this:

{caption: "React blackbox axis", line-numbers: false, format: javascript}
```
class Axis extends Component {
	gRef = React.createRef();
		
	componentDidMount() { this.d3render() }
	componentDidUpdate() { this.d3render() }

	d3render() {
		const scale = d3.scaleLinear()
	                  .domain([0, 10])
	                  .range([0, 200]);
    	const axis = d3.axisBottom(scale);

		d3.select(this.gRef)
		  .call(axis);  
	}

	render() {
    	return <g transform="translate(10, 30)" ref={this.gRef} />
	}
}
```

So much code! Worth it for the other benefits of using React in your dataviz. You'll see :)

We created an `Axis` component that extends React's base `Component` class. We can't use functional components because we need lifecycle hooks. 

Our component has a `render` method. It returns a grouping element (`g`) moved 10px to the right and 30px down using the `transform` attribute. Same as before.

A React ref saved in `this.gRef` and passed into our `<g>` element with `ref` lets us talk to the DOM node directly. We need this to hand over rendering control to D3.

The `d3render` method looks familiar. It's the same code we used in the vanilla D3 example. Scale, axis, select, call. Only difference is that instead of selecting `svg` and appending a `g` element, we select the `g` element rendered by React and use that.

We use `componentDidUpdate` and `componentDidMoutn` to keep our render up to date. Ensures that our axis re-renders every time React's engine decides to render our component.

That wasn't so bad, was it? 

[Try it out on Codesandbox](https://codesandbox.io/s/3xy2jr1y5m).

You can make the axis more useful by getting positioning, scale, and orientation from props. We'll do that in our big project.

### Practical exercise

Try implementing those as an exercise. Make the axis more reusable with some carefully placed props.

Here's my solution, if you get stuck ðŸ‘‰ [https://codesandbox.io/s/5ywlj6jn4l](https://codesandbox.io/s/5ywlj6jn4l)

{#blackbox-hoc}
# A D3 blackbox higher order component â€“ HOC

After that example you might think this is hella tedious to implement every time. You'd be right!

Good thing you can abstract it all away with a higher order component â€“Â a HOC. Now this is something I should open source (just do it already), but I want to show you how it works so you can learn about the HOC pattern.

Higher order components are great when you see multiple React components sharing similar code. In our case, that shared code is:

- rendering an anchor element
- calling D3's render on updates

With a HOC, we can abstract that away into a sort of [object factory](https://en.wikipedia.org/wiki/Factory_method_pattern). It's an old concept making a comeback now that JavaScript has classes.

Think of our HOC as a function that takes some params and creates a class â€“ a React component. Another way to think about HOCs is that they're React components wrapping other React components and a function that makes it easy.

A HOC for D3 blackbox integration, called `D3blackbox`, looks like like this:

{caption: "React blackbox HOC", line-numbers: false, format: javascript}
```
function D3blackbox(D3render) {
	return class Blackbox extends React.Component {
		anchor = React.createRef();
		
		componentDidMount() { D3render.call(this); }
		componentDidUpdate() { D3render.call(this) }

		render() {
	    const { x, y } = this.props;
	    return <g transform={`translate(${x}, ${y})`} ref={this.anchor} />;
		}
	}
}
```

You'll recognize most of that code from earlier. 

We have `componentDidMount` and`componentDidUpdate` lifecycle hooks that call `D3render` on component updates. `render` renders a grouping element as an anchor with a ref so D3 can use it to render stuff into.

Because `D3render` is no longer a part of our component, we have to use `.call` to give it the scope we want: this class, or rather `this` instance of the `Blackbox` class.

We've also made some changes that make `render` more flexible. Instead of hardcoding the `translate()` transformation, we take `x` and `y` props. `{ x, y } = this.props` takes `x` and `y` out of `this.props` using object decomposition, and we used ES6 string templates for the `transform` attribute.

Consult the [ES6 cheatsheet](https://es6cheatsheet.com/) for details on the syntax.

Using our new `D3blackbox` HOC to make an axis looks like this:

{caption: "React blackbox HOC", line-numbers: false, format: javascript}
```
const Axis = D3blackbox(function () {
    const scale = d3.scaleLinear()
	            .domain([0, 10])
	            .range([0, 200]);
    const axis = d3.axisBottom(scale);

    d3.select(this.anchor)
      .call(axis);    
});
```

You know this code! We copy pasted our axis rendering code from before, wrapped it in a function, and passed it into `D3blackbox`. Now it's a React component.

Play with this example on [Codesandbox, here](https://codesandbox.io/s/5v21r0wo4x).

{#magic-trick}
## D3blackbox magic trick â€“ render anything in 30 seconds

Let me show you a magic trick. 30 seconds to take a random D3 piece of code and add it to your React project.

We can try it on the example barchart from before.

![An example D3 barchart](images/2018/barchart-example.png)

You can [try it online](https://cdn.rawgit.com/mbostock/3885304/raw/a91f37f5f4b43269df3dbabcda0090310c05285d/index.html). When you hover on a bar, it changes color. Pretty neat.

I recommend you follow along in a CodeSandbox. If you fork the [react-d3-axis-hoc CodeSandbox](https://codesandbox.io/s/5v21r0wo4x) that will be easiest.

You should already have the `D3blackbox` HOC. If you don't, make a new file and paste it in.

With your HOC ready, create a new file in CodeSandbox. Call it `Barchart.js`.

Add your imports:

{caption: "Import dependencies", line-numbers: false}
```javascript
import React from 'react';
import D3blackbox from './D3blackbox';
import * as d3 from 'd3';
```

This gives you React, our HOC, and D3.

Now right-click view code on that barchart and copy the code. Wrap it in a `D3blackbox` call. Like this:

{caption: "Wrap D3 code in D3blackbox", line-numbers: false}
```javascript
const Barchart = D3blackbox(function () {
	var svg = d3.select("svg"),
	    margin = {top: 20, right: 20, bottom: 30, left: 40},
	    width = +svg.attr("width") - margin.left - margin.right,
	    height = +svg.attr("height") - margin.top - margin.bottom;
	
	var x = d3.scaleBand().rangeRound([0, width]).padding(0.1),
	    y = d3.scaleLinear().rangeRound([height, 0]);
	
	var g = svg.append("g")
	    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	
	d3.tsv("data.tsv", function(d) {
	  d.frequency = +d.frequency;
	  return d;
	}, function(error, data) {
	  if (error) throw error;
	
	  x.domain(data.map(function(d) { return d.letter; }));
	  y.domain([0, d3.max(data, function(d) { return d.frequency; })]);
	
	  g.append("g")
	      .attr("class", "axis axis--x")
	      .attr("transform", "translate(0," + height + ")")
	      .call(d3.axisBottom(x));
	
	  g.append("g")
	      .attr("class", "axis axis--y")
	      .call(d3.axisLeft(y).ticks(10, "%"))
	    .append("text")
	      .attr("transform", "rotate(-90)")
	      .attr("y", 6)
	      .attr("dy", "0.71em")
	      .attr("text-anchor", "end")
	      .text("Frequency");
	
	  g.selectAll(".bar")
	    .data(data)
	    .enter().append("rect")
	      .attr("class", "bar")
	      .attr("x", function(d) { return x(d.letter); })
	      .attr("y", function(d) { return y(d.frequency); })
	      .attr("width", x.bandwidth())
	      .attr("height", function(d) { return height - y(d.frequency); });
	});
})

export default Barchart;
```

That should throw some errors. We have to change the `d3.select` and get `width` and `height` from props.

{caption: "Change where D3 renders", line-numbers: false}
```javascript
const Barchart = D3blackbox(function () {
  // markua-start-delete
	var svg = d3.select("svg"),
  // markua-end-delete
  // markua-start-insert
  var svg = d3.select(this.anchor.current)
  // markua-end-insert
	    margin = {top: 20, right: 20, bottom: 30, left: 40},
	    // markua-start-delete
	    width = +svg.attr("width") - margin.left - margin.right,
	    height = +svg.attr("height") - margin.top - margin.bottom;
	    // markua-end-delete
	    // markua-start-insert
	    width = +this.props.width - margin.left - margin.right,
	    height = +this.props.height - margin.top - margin.bottom;
	    // markua-end-insert
```


Most D3 examples use a global `svg` variable to refer to their drawing area â€“Â the SVG. Change that to the element you want, your anchor, and the whole visualization should render in there.

We also replaced reading width and height from the SVG element to getting them from props. This makes our component more reusable and better follows best practices.

Next step is to change where our barchart gets its data. Gotta use the public URL.

{caption: "Change data URL", line-numbers: false}
```javascript
//markua-start-delete
d3.tsv("data.tsv", function(d) {
// markua-end-delete
// markua-start-insert
d3.tsv("https://cdn.rawgit.com/mbostock/3885304/raw/a91f37f5f4b43269df3dbabcda0090310c05285d/data.tsv", function(d) {
// markua-end-insert
	  d.frequency = +d.frequency;
	  return d;
// markua-start-delete
	}, function(error, data) {
	  if (error) throw error;
// markua-end-delete
// markua-start-insert
	}).then(function(data) {
// markua-end-insert
```

Same link, absolute version. And we updated the callback-based code to use the D3v5 promises version. That's the most disruptive change going from v4 to v5 I believe.

That's it. You now have a Barchart component that renders the example barchart from D3's docs.

You can use it like this ðŸ‘‡ I recommend adding this code to the main App component that CodeSandbox creates for you.

{caption: "Use the Barchart", line-numbers: false}
```javascript
import Barchart from './Barchart';

// ...
return (
	<svg width="800" height="600">
		<Barchart x={10} y={10} width={400} height={300} />
	</svg>
)
```

But like I said, don't use this in production. It's great for quick prototypes, trying stuff out, or seeing how an existing visualization might fit your app.

{#full-feature-integration}
# Build scalable dataviz components with full integration

As useful as blackbox components are, we need something better to really leverage React's rendering engine. We're going to look at full-feature integration where React does the rendering and D3 calculates the props.

To do that, we're going to follow a 3-part pattern:
- set up D3 objects as class properties
- update D3 objects when component updates
- output SVG in `render()`

It's easiest to show you with an example.

Let's build a rectangle that changes color based on prop values. We'll render a few of them to make a color scale.

Yes, it looks like a trivial example, but color-as-information is an important concept in data visualization. We're going to use it later to build a choropleth map of household income in the US.

I suggest following along in Codepen for now. [Here's one I set up for you](https://codepen.io/swizec/pen/oYNvpQ). It contains the final solution, so you can follow along and nod your head. I'll explain each part.

## A color scale

We start with a `Swatch` component that draws a rectangle and fills it with a color.

{caption: "Swatch component", line-numbers: false, format: javascript}
```
const Swatch = ({ color, width, x }) => (
	<rect width={width}
			  height="20"
			  x={x}
			  y="0"
			  style={{fill: color}} />
);
```

Looks like our earlier components, doesn't it? It's exactly the same: a functional stateless component that draws a `rect` element with some attributes - dimensions, position, and `fill` style.

Note that `style` is a dictionary, so we specify it with double curly braces: outer braces for a dynamic value, inner braces for a dictionary.

Then we need a `Colors` component. It follows the full-featured integration structure: D3 objects as properties, an `updateD3` function, plus some wiring for updates and rendering.

{caption: "Colors component, pt1", line-numbers: false, format: javascript}
```
class Colors extends Component {
    colors = d3.schemeCategory20;
    width = d3.scaleBand()
				      .domain(d3.range(20));
```

We start by inheriting from `Component` and defining defaults for D3 objects. `this.colors` is one of [D3's predefined color scales](https://github.com/d3/d3-scale/blob/master/README.md#schemeCategory10). `schemeCategory20` is a scale of 20 colors designed for categorization. It seemed like a good example, and you're welcome to try others.

`this.width` is a D3 scale designed for producing bands, `d3.scaleBand`. As mentioned earlier, scales map domains to ranges. We know our domain is 20 colors, so we can statically set the domain as `[1, 2, 3, ..., 20]` with `d3.range(20)`.

`d3.range` generates a counting array, by the way. We'll use that often.

We'll use `this.width` to calculate widths and positions of our color swatches. Here's a picture from D3 docs to help you visualize what `scaleBand` does:

![Band Scale from D3 docs](https://raw.githubusercontent.com/d3/d3-scale/master/img/band.png)

Unlike the domain, our range is dynamic so that we can use props to define the width of our color scale. This makes the component more reusable.

{caption: "Colors component, pt2", line-numbers: false, format: javascript}
```
componentWillMount() {
    this.updateD3(this.props);
}

componentWillUpdate(newProps) {
    this.updateD3(newProps);
}

updateD3(props) {
    this.width.range([0, props.width]);
}
```

`componentWillMount` and `componentWillUpdate` are component lifecycle hooks. Can you guess when they run?

`componentWillMount` runs just before React's engine inserts our component into the DOM, and `componentWillUpdate` runs just before React updates it. That happens on any prop change or `setState` call.

Both of them call our `updateD3` method with the new value of props. We use it to update `this.width` scale's range. Doing so keeps the internal state of D3 objects in sync with React's reality. Without it, our component might render stale data.

Finally, we render a set of color swatches.

{caption: "Colors component, pt3", line-numbers: false, format: javascript}
```
render() {
	return (
		<g>
	    {d3.range(20).map(i => (
	        <Swatch color={this.colors[i]}
	                width={this.width.step()}
	                x={this.width(i)} />
	     ))}
		</g>
	)
}
```

We create a grouping element to fulfill React's one child per component requirement, then render 20 swatches in a loop. Each gets a `color` from `this.colors` and a `width` and `x` from `this.width`.

After inserting into the DOM with `ReactDOM`, we get a series of 20 colorful rectangles.

![20 color swatches](images/es6v2/color-swatches.png)

Try changing the `width="400"` property of `<Colors />`. You'll see D3's `scaleBand` and our update wiring ensure the color strip renders correctly. For more fun, try changing the `Colors` component so it takes the color scale as a prop, then rendering multiple instances of `<Colors />` side-by-side.

Here's the playground again: [CodePen](https://codepen.io/swizec/pen/oYNvpQ)

As an exercise, try to add another row of swatches, but rendered in reverse.

# You're awesome

You know the basics! You can take any D3 example from the internets and wrap it in a React component, *and* you know how to build React+D3 components from scratch. You're amazing. High five! :raised_hand_with_fingers_splayed:

The rest of this book is about using these concepts and pushing them to the limits of practicality. We're going to build an interactive visualization of tech salaries compared to median household income. Why? Because it piqued my interest, and because it shows why you should call yourself an engineer, not a programmer or a developer. **You're an engineer**. Remember that.

Throughout the example, you'll learn more details of D3, tidbits from React, and the animation chapter is going to blow your mind. It's gonna be fun!

![Default view](images/es6v2/full-dataviz.png)

![After a click](images/es6v2/interaction-dataviz.png)

{#state-handling-architecture}
# State Handling Architecture

Before I can set you loose on the world, we should talk about managing state. It's where most engineers shoot themselves in the foot.

I've shot myself in the foot *a lot*. Life gets harder and harder until one day you want to throw all your code away and embark on The Rewrite. That's how projects die.

The Rewrite [killed Netscape](http://www.joelonsoftware.com/articles/fog0000000069.html). You probably don't even remember Netscape :wink:

Let's save you from that.

{#basic-architecture}
## Basic architecture

![The basic architecture](images/es6v2/architecture.jpg)

We're going to use a unidirectional dataflow architecture inspired by Flux:

* The Main Component â€“ `App` â€“ is the repository of truth
* Child components react to user events
* They announce changes using callbacks
* The Main Component updates its truth
* The real changes flow back down the chain to update UI

This looks roundabout, but it's awesome. It's far better than worrying about parts of the UI going out of date with the rest of the app. I could talk your ear off with debugging horror stories, but I'm nice, so I won't.

When a user clicks on one of our controls, a `Toggle`, it invokes a callback. This in turn invokes a callback on `ControlRow`, which invokes a callback on `Controls`, which invokes a callback on `App`.

![Callback chain](images/es6v2/architecture_callbacks.jpg)

With each hop, the nature of our callback changes. `Toggle`  tells `ControlRow` which entry was toggled, `ControlRow` tells `Controls` how to update the data filter function, and `Controls` gives `App` a composite filter built from all the controls. You'll see how that works in the next chapter.

The important takeaway right now is that callbacks go from low-level info to high-level semantic info.

When the final callback is invoked, `App` updates its repository of truth and communicates the change back down the chain via props. This happens with no additional wiring on your part.

![Data flows down](images/es6v2/architecture_dataflow.jpg)

You can think of it like calling functions with new arguments. Because the functions â€“ components â€“ render the UI, your interface updates.

Because your components are well-made and rely on their props to render, React's engine can optimize these changes. It can compare the component tree and decide which components to re-render and which to leave alone.

Functional programming for HTML! :sunglasses:

The functional programming concepts we're relying on are called [referential transparency](https://en.wikipedia.org/wiki/Referential_transparency), [idempotent functions](https://en.wikipedia.org/wiki/Idempotence), and [functional purity](https://en.wikipedia.org/wiki/Pure_function). I suggest Googling them if you want to learn the theory behind it all.

## A caveat

The caveat with our basic state handling approach is that it's less flexible and scalable than using a state handling library like Redux or MobX. The more components we add, and the more interaction we come up with, the harder it will become to keep track of our callbacks. Redesigning the UI is also cumbersome because you have to rewire all the callbacks.

We're using the basic approach because it's easier to explain, works without additional libraries, and is Good Enoughâ„¢. I mention Redux and MobX to make your Googling easier.

You can see an approach to using Redux in dataviz in the [Animating with React, Redux, and D3 chapter](#animating-react-redux), and we'll tackle MobX in the [MobX chapter](#refactoring-to-mobx).


{#structuring-your-app}
# Structuring your React app

We're going to structure our app into components. Deciding what to put into one component and what to put into another is one of the hardest problems in engineering.

Entire books have been written on the topic, but here's a rule of thumb that I like to use: if you have to use the word "and" to describe what your component does, then it should become two components.

Once you have those two components, you can either make them child components of a bigger component, or you can make them separate. The choice depends on their re-usability and often mimics your design structure.

For example, our tech salary visualization is going to use 1 very top level component, 5 major components, and a bunch of child components.

 - `App` is the very top level component; it handles everything
 - `Title` renders the dynamic title
 - `Description` renders the dynamic description
 - `Histogram` renders the histogram and has child components for the axis and histogram bars
 - `CountyMap` renders the choropleth map and uses child components for the counties
 - `Controls` renders the rows of buttons that let users explore our dataset

Most of these are specific to our use case, but `Histogram` and `CountyMap` have potential to be used elsewhere. We'll keep that mind when we build them.

`Histogram`, `CountyMap`, and `Controls` are going to have their own folder inside `src/components/` to help us group major components with their children. An `index.js` file will help with imports.

We'll use a `Meta` folder for all our metadata components like `Title` and `Description`. We don't *have* to do this, but `import { Title, Description } from './Meta'` looks better than doing separate imports for related-but-different components. Namespacing, if you will.

Each component should be accessible with `import My Component from './MyComponent'` and rendered with `<MyComponent {...params} />`. If a parent component has to know details about the implementation of a child component, something is wrong.

You can read more about these ideas by Googling ["leaky abstractions"](https://en.wikipedia.org/wiki/Leaky_abstraction), ["single responsibility principle"](https://en.wikipedia.org/wiki/Single_responsibility_principle), ["separation of concerns"](https://en.wikipedia.org/wiki/Separation_of_concerns), and ["structured programming"](https://en.wikipedia.org/wiki/Structured_programming). Books from the late 90's and early 2000's (when object-oriented programming was The Futureâ„¢) are the best source of curated info in my experience.

---

Congratz! You know everything you need to build visualizations with React and D3. :clap:

This is the point in tech books where I run off and start building things on my own. Then I get frustrated, spend hours Googling for answers, and then remember, "Hey! Maybe I should read the rest of the book!"

Reading the rest of the book helps. I'll show you how all this stuff fits together into a larger project.
